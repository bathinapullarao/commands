**Helm uses the current Kubernetes context from your kubeconfig file (usually ~/.kube/config).
kubectl config current-context
kubectl config use-context <context-name>
helm create mychart                <--create folder structure
helm package mychart               <--packges to filename.tgz file
helm install myrelease mychart     <--deploys, myrelease: The name you are giving to this Helm release. Helm uses this name to track and manage the deployment.
helm list                          <--Check the Helm releases in your current namespace
helm list --all-namespaces         <--lists all Helm releases (i.e., applications deployed using Helm) across every Kubernetes namespace in your cluster
helm upgrade myrelease mychart     <--To update the deployment with changes to the chart or values
helm rollback myrelease 1          <--revertback to previous version, 1: The target revision number to roll back to.
helm uninstall myrelease           <--delete the release and its resources
helm install myrelease mychart -f custom-values.yaml  <--mychart: The Helm chart to install (should be in the local directory 
                                    or a Helm repository).
                                  -f custom-values.yaml: Specifies a custom values.yaml file to override default values in the chart.
helm history myrelease          <--This will show the revision history of myrelease, so you can confirm which version you want to roll back to.             
helm history <release-name> --namespace <namespace>
helm rollback <release-name> <revision> --namespace <namespace>

To package and deploy applications using Helm, you need to create a Helm chart and use it to manage the Kubernetes resources for your application. Here's a step-by-step guide:

1. Install Helm
Make sure Helm is installed on your system. You can download and install it by following the Helm installation guide.

2. Create a Helm Chart
Run the following command to create a new Helm chart:

#bash
helm create mychart
This creates a directory structure like this:

mychart/
â”œâ”€â”€ Chart.yaml
â”œâ”€â”€ values.yaml
â”œâ”€â”€ charts/
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â”œâ”€â”€ service.yaml
â”‚   â”œâ”€â”€ ingress.yaml
â”‚   â”œâ”€â”€ _helpers.tpl
â”‚   â””â”€â”€ NOTES.txt
3. Customize the Helm Chart
Edit Chart.yaml: Define metadata about your chart, such as its name and version.
Edit values.yaml: Add default values for your application (e.g., image name, replica count, ports).
Edit Templates:
Modify deployment.yaml to define your application's Deployment.
Modify service.yaml to define your application's Service.
Add or edit other templates as needed (e.g., ConfigMaps, Secrets, Ingress).
4. Package the Helm Chart
To package the Helm chart into a .tgz file:

**helm package mychart**
This creates a file like mychart-0.1.0.tgz.

5. Deploy the Application
Use the following command to deploy your Helm chart:
**helm install myrelease mychart**

myrelease is the release name.
mychart is the path to your chart directory or the .tgz file.
6. Verify the Deployment
Check the Helm releases:
**helm list**
Check the Kubernetes resources created:
**kubectl get all**

7. Update the Deployment
To update the deployment with changes to the chart or values, use:
**helm upgrade myrelease mychart**
8. Rollback a Release
If something goes wrong, you can roll back to a previous version:
**helm rollback myrelease 1**
1 is the revision number to roll back to.
9. Delete the Deployment
To delete the release and its resources:
**helm uninstall myrelease**
Additional Notes:
Using Custom Values: You can override default values in values.yaml using a custom file or inline:

**helm install myrelease mychart -f custom-values.yaml**
or
**helm install myrelease mychart --set key=value**
Helm Repository: If you want to share your chart, you can host it in a Helm repository.

helm history <release-name> --namespace <namespace>
helm rollback <release-name> <revision> --namespace <namespace>
----------------------------------------------------------------------------------------------------
You have 6 microservices in Kubernetes, and you want flexibility to deploy one, some, or all of them using Helm â€” cleanly, with reusable structure.
Letâ€™s go step-by-step ğŸ‘‡
ğŸ¯ Goal
You want:To manage 6 microservices (say user, order, payment, inventory, notification, gateway)
Sometimes deploy only one (e.g., just order)
Sometimes deploy multiple or all

âœ… Helm can handle this perfectly using an Umbrella Chart with subcharts or an enable flag per microservice.
Weâ€™ll use the Umbrella chart pattern, as itâ€™s clean and scales well.

ğŸ— Folder Structure
myapp/
â”œâ”€â”€ Chart.yaml
â”œâ”€â”€ values.yaml
â””â”€â”€ templates/
    â”œâ”€â”€ _helpers.tpl
    â”œâ”€â”€ user-deploy.yaml
    â”œâ”€â”€ order-deploy.yaml
    â”œâ”€â”€ payment-deploy.yaml
    â”œâ”€â”€ inventory-deploy.yaml
    â”œâ”€â”€ notification-deploy.yaml
    â””â”€â”€ gateway-deploy.yaml

âš™ï¸ Step 1: Chart.yaml
apiVersion: v2
name: myapp
description: Helm chart for 6 microservices
version: 1.0.0
appVersion: "1.0"


âš™ï¸ Step 2: values.yaml
Here you define which microservices are enabled and what images they use.
global:
  namespace: default

services:
  user:
    enabled: true
    image: myrepo/user-service
    tag: v1.0
    port: 8081

  order:
    enabled: false
    image: myrepo/order-service
    tag: v1.0
    port: 8082

  payment:
    enabled: true
    image: myrepo/payment-service
    tag: v1.0
    port: 8083

  inventory:
    enabled: false
    image: myrepo/inventory-service
    tag: v1.0
    port: 8084

  notification:
    enabled: false
    image: myrepo/notification-service
    tag: v1.0
    port: 8085

  gateway:
    enabled: true
    image: myrepo/gateway-service
    tag: v1.0
    port: 8080


âš™ï¸ Step 3: _helpers.tpl (for naming consistency)
{{- define "myapp.fullname" -}}
{{ printf "%s-%s" .Release.Name .Chart.Name | trunc 63 | trimSuffix "-" }}
{{- end -}}


âš™ï¸ Step 4: Example Deployment Template (templates/user-deploy.yaml)
Youâ€™ll reuse the same pattern for all 6 microservices.
{{- if .Values.services.user.enabled }}
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  labels:
    app: user-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
        - name: user-service
          image: "{{ .Values.services.user.image }}:{{ .Values.services.user.tag }}"
          ports:
            - containerPort: {{ .Values.services.user.port }}
---
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
    - port: 80
      targetPort: {{ .Values.services.user.port }}
{{- end }}

ğŸ”¹ Copy this template and rename for each microservice (order-deploy.yaml, payment-deploy.yaml, etc.)
ğŸ”¹ Only difference: reference services.order, services.payment, etc.

âš™ï¸ Step 5: Deploy
ğŸŸ¢ Deploy all enabled microservices
helm install myapp ./myapp

This will deploy only services where enabled: true in values.yaml.

ğŸŸ¡ Deploy only specific services dynamically
helm upgrade myapp ./myapp \
  --set services.order.enabled=true \
  --set services.user.enabled=false

âœ… You can enable or disable any service at deploy time.

ğŸ” Update image for one service
helm upgrade myapp ./myapp \
  --set services.payment.tag=v2.0


âŒ Remove all resources
helm uninstall myapp


ğŸ§  Output Example
If in your values.yaml, only user, payment, and gateway are enabled â€”
Helm will render and deploy only those 3 manifests.
The rest are ignored (order, inventory, notification).

âš¡ Bonus: Shorter Templating (Optional)
You can use a loop to avoid writing 6 separate YAMLs.
templates/deployment.yaml
{{- range $name, $svc := .Values.services }}
{{- if $svc.enabled }}
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ $name }}-svc
spec:
  replicas: 1
  selector:
    matchLabels:
      app: {{ $name }}-svc
  template:
    metadata:
      labels:
        app: {{ $name }}-svc
    spec:
      containers:
      - name: {{ $name }}-svc
        image: "{{ $svc.image }}:{{ $svc.tag }}"
        ports:
        - containerPort: {{ $svc.port }}
---
apiVersion: v1
kind: Service
metadata:
  name: {{ $name }}-svc
spec:
  selector:
    app: {{ $name }}-svc
  ports:
    - port: 80
      targetPort: {{ $svc.port }}
{{- end }}
{{- end }}

âœ… This single file will automatically handle all 6 microservices based on your values.yaml.

âœ… Summary
FeatureDescriptionChart typeUmbrella (manages all 6 microservices)ControlEnable/disable each service from values.yamlDeploy one or manyUse --set services.<name>.enabled=trueBenefitSingle Helm chart manages all microservicesMaintenanceAdd new services easily without changing logic

Would you like me to extend this example to include ConfigMap and Secret handling per microservice (so each service gets its own config and secret)? Thatâ€™s a natural next step for production-grade Helm usage.
